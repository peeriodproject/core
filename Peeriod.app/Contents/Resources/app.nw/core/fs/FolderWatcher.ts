/// <reference path='../../main.d.ts' />

import events = require('events');
import fs = require('fs');

import AppQuitHandlerInterface = require('../utils/interfaces/AppQuitHandlerInterface');
import ConfigInterface = require('../config/interfaces/ConfigInterface');
import ClosableOptions = require('../utils/interfaces/ClosableOptions');
import FolderWatcherDelayedEventInterface = require('./interfaces/FolderWatcherDelayedEventInterface');
import FolderWatcherDelayedEventMapInterface = require('./interfaces/FolderWatcherDelayedEventMapInterface');
import FolderWatcherDelaysInterface = require('./interfaces/FolderWatcherDelaysInterface');
import FolderWatcherInterface = require('./interfaces/FolderWatcherInterface');
import PathListInterface = require('./interfaces/PathListInterface');

//var monitor = require('usb-detection');
var chokidar = require('chokidar');
var EventEmitter = events.EventEmitter;

import ObjectUtils = require('../utils/ObjectUtils');

/**
 * @class core.fs.FolderWatcher
 * @implements core.fs.FolderWatcherInterface
 *
 * @param {core.config.ConfigInterface} config
 * @param {core.utils.AppQuitHandlerInterface} appQuitHandler
 * @param {string} pathToWatch The absolute path to the folder the watcher should manage.
 * @param {core.utils.ClosableOptions} options (optional)
 */
class FolderWatcher implements FolderWatcherInterface {

	/**
	 * The internally used config instance
	 *
	 * @member {core.config.ConfigInterface} core.fs.FolderWatcher~_config
	 */
	private _config:ConfigInterface = null;

	/**
	 * A list of paths that refer to zero byte files. Zero byte files are generated by os x during the copy process.
	 *
	 * @see core.fs.FolderWatcher~_checkEmptyFilePaths
	 *
	 * @member {core.fs.PathListInterface} core.fs.FolderWatcher~currentEmptyFilePaths
	 */
	private _currentEmptyFilePaths:PathListInterface = [];

	/**
	 * A map of delayed events
	 * @type {{}}
	 * @private
	 */
	private _currentDelayedEvents:FolderWatcherDelayedEventMapInterface = {};

	private _eventDelayOptions:FolderWatcherDelaysInterface = null;

	/**
	 * The event emitter instance that is used to emit changes within the folder this watcher instance is handling
	 *
	 * @member {events.EventEmitter} core.fs.FolderWatcher~_eventEmitter
	 */
	private _eventEmitter:events.EventEmitter = null;

	/**
	 * A flag indicates whether the watcher is open (active) or closed (inactive)
	 *
	 * @member {boolean} core.fs.FolderWatcher~_isOpen
	 */
	private _isOpen:boolean = false;

	/**
	 * The options object
	 *
	 * @member {core.utils.ClosableOptions} _options
	 */
	private _options:ClosableOptions = null;

	/**
	 * The folder path the watcher is watching
	 *
	 * @member {string} core.fs.FolderWatcher~_path
	 */
	private _path:string = null;

	// todo ts-definitions chokidar.d.ts
	private _watcher:any = null;

	constructor (config:ConfigInterface, appQuitHandler:AppQuitHandlerInterface, pathToWatch:string, options:ClosableOptions = {}) {
		var defaults:ClosableOptions = {
			closeOnProcessExit: true
		};

		this._config = config;
		this._path = pathToWatch;
		this._options = ObjectUtils.extend(defaults, options);

		this._eventDelayOptions = {
			interval      : this._config.get('fs.folderWatcher.interval'),
			binaryInterval: this._config.get('fs.folderWatcher.binaryInterval'),
			eventDelay    : this._config.get('fs.folderWatcher.eventDelay')
		}

		if (this._options.closeOnProcessExit) {
			appQuitHandler.add((done) => {
				this.close();
				done();
			});
		}

		this.open();
	}

	public close ():void {
		if (!this._isOpen) {
			return;
		}

		// clean up watcher
		this._watcher.close();
		this._watcher = null;

		// clean up event emitter
		this._eventEmitter.removeAllListeners();
		this._eventEmitter = null;

		this._isOpen = false;
	}

	public isOpen ():boolean {
		return this._isOpen;
	}

	public off (eventName:string, callback:Function):void {
		this._eventEmitter.removeListener(eventName, callback);
	}

	public on (eventName:string, callback:Function):void {
		this._eventEmitter.addListener(eventName, callback);
	}

	public open ():void {
		if (this._isOpen) {
			return;
		}

		this._eventEmitter = new EventEmitter();

		this._watcher = chokidar.watch(this._path, {
			ignored       : /[\/\\]\./,
			persistent    : true,
			interval      : this._eventDelayOptions.interval,
			binaryInterval: this._eventDelayOptions.binaryInterval,
			usePolling	  : this._config.get('fs.folderWatcher.usePolling')
		});

		this._registerWatcherEvents();

		this._isOpen = true;
	}

	// todo bind to seperate event listeners.
	private _registerWatcherEvents ():void {
		this._watcher.on('all', (eventName:string, changedPath:string) => {
			//console.log(eventName);
			if (['add', 'change', 'unlink'].indexOf(eventName) !== -1) {
				this._processDelayedEvent(eventName, changedPath);
			}
			else if (eventName === 'addDir') {
				//console.log('added directory', this._logPath(changedPath));
			}
			else if (eventName === 'unlinkDir') {
				//console.log('removed directory', this._logPath(changedPath));
			}
			else if (eventName !== 'error') {
				//console.log('=== Undelayed Event ===');
				//console.error(eventName, changedPath);
			}
			else {
				//console.log('=== Unhandled Event ===');
				//console.error(eventName, changedPath);
			}
		});
	}

	/**
	 * Creates or updates an existing delayed event for the given eventName and path
	 *
	 * @method core.fs.FolderWatcher~_processDelayedEvent
	 *
	 * @param {string} eventName
	 * @param {string} changedPath
	 */
	private _processDelayedEvent (eventName:string, changedPath:string):void {
		if (!this._eventExists(changedPath)) {
			this._createDelayedEvent(eventName, changedPath);
		}
		else {
			this._updateDelayedEvent(eventName, changedPath);
		}
	}

	/**
	 * Updates the delayed event for the given event name and path by clearing the old timeout, updating the event name
	 * and file size and registering a new {@link core.fs.FolderWatcher~_getDelayedTriggerMethod} in the
	 * {@link core.fs.FolderWatcher~_currentDelayedEvents} list.
	 *
	 * @method core.fs.FolderWatcher~_updateDelayedEvent
	 *
	 * @param {string} eventName
	 * @param {string} changedPath
	 * @param {number} timeoutIdentifier (optional)
	 */
	private _updateDelayedEvent (eventName:string, changedPath:string, timeoutIdentifier?:number) {
		var delayedEvent:FolderWatcherDelayedEventInterface = this._currentDelayedEvents[changedPath];

		if (!delayedEvent) {
			return;
		}

		this._getFileSize(changedPath, (fileSize:number, stats:fs.Stats) => {
			//console.log('- removing old event');
			clearTimeout(delayedEvent.timeout);

			//console.log('- updating properties');
			// update event name
			if (delayedEvent.eventName !== eventName) {
				//console.log('  - event name');
				this._currentDelayedEvents[changedPath].eventName = eventName;
			}

			// update fileSize
			//console.log('  - file size');
			this._currentDelayedEvents[changedPath].fileSize = fileSize;

			// update timeout function
			//console.log('  - timeout');
			timeoutIdentifier = timeoutIdentifier || this._getDelayedTriggerMethod(eventName, changedPath);
			this._currentDelayedEvents[changedPath].timeout = timeoutIdentifier;
		});

	}

	/**
	 * Returns the delayed {@link core.fs.FolderWatcher~_triggerDelayedEvent} function for the specified event name and path
	 *
	 * @method core.fs.FolderWatcher~_getDelayedTriggerMethod
	 *
	 * @param {string} eventName
	 * @param {string} changedPath
	 * @returns {number|NodeJS.Timer}
	 */
	private _getDelayedTriggerMethod (eventName:string, changedPath:string):number {
		//console.log('  - creating delayed trigger method');
		var delay:number = this._eventDelayOptions.binaryInterval + 1000;

		return setTimeout(() => {
			//console.log('going to trigger delayed event for ' + this._logPath(changedPath));

			this._triggerDelayedEvent(eventName, changedPath);
		}, delay);
	}

	/**
	 * Creates a new delayed event for the given event name and path and registeres it in the
	 * {@link core.fs.FolderWatcher~_currentDelayedEvents} list
	 *
	 * @method core.fs.FolderWatcher~_createDelayedEvent
	 *
	 * @param {string} eventName
	 * @param {string} changedPath
	 * @param {boolean} isEmptyFile (optional) default `false`
	 */
	private _createDelayedEvent (eventName:string, changedPath:string, isEmptyFile:boolean = false) {
		//console.log('- creating delayed event ' + eventName + ' for ' + this._logPath(changedPath));
		this._getFileSize(changedPath, (fileSize:number, stats:fs.Stats) => {
			this._currentDelayedEvents[changedPath] = {
				eventName       : eventName,
				fileSize        : fileSize,
				initialEventName: eventName,
				isEmptyFile     : isEmptyFile,
				timeout         : this._getDelayedTriggerMethod(eventName, changedPath)
			}
		});
	}

	/**
	 * Returns the file size for the specified path or -1 if the file does not exist
	 *
	 * @method core.fs.FolderWatcher~_getFileSize
	 *
	 * @param filePath
	 * @param callback
	 */
	private _getFileSize (filePath:string, callback:(fileSize:number, stats:fs.Stats) => void):void {
		fs.stat(filePath, function (err:Error, stats:fs.Stats) {
			var fileSize:number = err ? -1 : stats.size;
			stats = stats || null;

			if (stats) {
				delete stats.atime;
			}

			callback(fileSize, stats);
		});
	}

	/**
	 * Returns `true` if a event exists for the the given path
	 *
	 * @method core.fs.FolderWatcher~_eventExists
	 *
	 * @param {string} changedPath
	 * @returns {boolean}
	 */
	private _eventExists (changedPath:string):boolean {
		return this._currentDelayedEvents[changedPath] ? true : false;
	}

	/**
	 * The current event gets updated and the file will be analysed after another delay before the event gets triggered.
	 *
	 * @see core.fs.FolderWatcher~_checkFileAndTriggerEvent
	 *
	 * @method core.fs.FolderWatcher~_triggerDelayedEvent
	 *
	 * @param {string} eventName
	 * @param {string} changedPath
	 */
	private _triggerDelayedEvent (eventName:string, changedPath:string):void {
		this._updateDelayedEvent(eventName, changedPath, setTimeout(() => {
			this._getFileSize(changedPath, (fileSize:number, stats:fs.Stats) => {
				this._checkFileAndTriggerEvent(eventName, changedPath, fileSize, stats);
			});
		}, this._eventDelayOptions.eventDelay));
	}

	/**
	 *
	 * Checks the fole before triggering the event.
	 *
	 * The following cases are covered:
	 *
	 * 1. The file size changed:
	 * A new event for further processing is created.
	 *
	 * 2.The file size is consistent
	 * - The file is a unknown "zero byte" file it will be added to the {@link core.fs.FolderWatcher~_currentEmptyFilePaths} list for further processing.
	 * - The file is a known "zero byte" file and will be ignored.
	 * - The file is not empty, the event will be triggered and the path will be removed from all lists.
	 *
	 * @method core.fs.FolderWatcher~_checkFileAndTriggerEvent
	 *
	 * @param {string} eventName
	 * @param {string} changedPath
	 * @param {number} fileSize
	 * @param {fs.Stats} stats
	 */
	private _checkFileAndTriggerEvent(eventName:string, changedPath:string, fileSize:number, stats:fs.Stats):void {
		var delayedEvent:FolderWatcherDelayedEventInterface = this._currentDelayedEvents[changedPath];

		if (delayedEvent.fileSize !== fileSize) {
			return this._triggerDelayedEvent(eventName, changedPath);
		}

		// Yeah! we have a consistent file...

		this._deleteFromDelayedEvents(changedPath);

		if (!fileSize) {
			if (!delayedEvent.isEmptyFile && this._currentEmptyFilePaths.indexOf(changedPath) === -1) {
				this._currentEmptyFilePaths.push(changedPath);
			}
		}
		else {
			var emptyFilePathIndex:number = this._currentEmptyFilePaths.indexOf(changedPath);

			if (emptyFilePathIndex !== -1) {
				this._currentEmptyFilePaths.splice(emptyFilePathIndex, 1);
			}

			this._triggerEvent(delayedEvent.initialEventName, changedPath, stats);

			this._checkEmptyFilePaths();
		}

	}

	/**
	 * Triggers the event to registered event listeners
	 *
	 * @method core.fs.FolderWatcher~_triggerEvent
	 *
	 * @param {string} eventName
	 * @param {string} filePath
	 * @param {fs.Stats} stats
	 */
	private _triggerEvent (eventName:string, filePath:string, stats:fs.Stats):void {
		//console.log("\n" + '=== EVENT ===');
		//console.log(eventName, this._logPath(filePath));
		//console.log("\n\n");

		if (this.isOpen()) {
			this._eventEmitter.emit(eventName, filePath, stats);
		}
	}

	/**
	 * Removes the corresponding delayed event for the given path from the {@link core.fs.FolderWatcher~_currentDelayedEvents} list.
	 *
	 * @method core.fs.FolderWatcher~_deleteFromDelayedEvents
	 *
	 * @param {string} changedPath
	 */
	private _deleteFromDelayedEvents (changedPath:string):void {
		this._currentDelayedEvents[changedPath] = null;

		delete this._currentDelayedEvents[changedPath];
	}

	/**
	 * Creates a new `add event` for all items within the {@link core.fs.FolderWatcher~_currentEmptyFilePaths} list if
	 * all pending events are triggered.The files will be removed from the {@link core.fs.FolderWatcher~_currentEmptyFilePaths}
	 * list and processed again.This is used to handle bulk copies on OS X as "zero byte" files won't trigger another event
	 * in the filesystem after the bulk copy process is done.
	 *
	 * @method core.fs.FolderWatcher~_checkEmptyFilePaths
	 */
	private _checkEmptyFilePaths ():void {
		// all delayed events are triggered. going to check the empty file paths.
		if (this._currentEmptyFilePaths.length && !Object.keys(this._currentDelayedEvents).length) {
			while (this._currentEmptyFilePaths.length) {
				var filePath:string = this._currentEmptyFilePaths.pop();

				this._createDelayedEvent('add', filePath, true);
			}
		}
	}
}

export = FolderWatcher;