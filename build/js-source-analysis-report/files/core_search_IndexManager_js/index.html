<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Plato - core/search/IndexManager.js</title>

  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="">
  <meta name="author" content="">

  <!--[if lt IE 9]>
  <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->

  <link href="../../assets/css/vendor/morris.css" rel="stylesheet">
  <link href="../../assets/css/vendor/bootstrap.css" rel="stylesheet">
  <link href="../../assets/css/vendor/font-awesome.css" rel="stylesheet">
  <link href="../../assets/css/vendor/font-awesome-ie7.css" rel="stylesheet">
  <link href="../../assets/css/vendor/codemirror.css" rel="stylesheet">
  <link href="../../assets/css/plato.css" rel="stylesheet">
  <link href="../../assets/css/plato-file.css" rel="stylesheet">

</head>

<body>

<div class="navbar navbar-fixed-top">
  <div class="container">
    <a class="navbar-brand" href="http://github.com/es-analysis/plato">Plato on Github</a>
    <ul class="nav navbar-nav">
      <li>
        <a href="../../index.html">Report Home</a>
      </li>
    </ul>
  </div>
</div>

<div class="jumbotron">
  <div class="container">
    <h1>core/search/IndexManager.js</h1>
  </div>
</div>

<div class="container aggregate-stats">
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Maintainability <a href="http://blogs.msdn.com/b/codeanalysis/archive/2007/11/20/maintainability-index-range-and-meaning.aspx"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="A value between 0 and 100 that represents the relative ease of maintaining the code. A high value means better maintainability." data-original-title="Maintainability Index"  data-container="body"></i></a></h2>
      <p class="stat">73.73</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Lines of code <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h2>
      <p class="stat">399</p>
    </div>
  </div>
  <div class="row historical">
    <div class="col-md-6">
      <p id="chart_historical_maint" class="chart"></p>
    </div>
    <div class="col-md-6">
      <p id="chart_historical_sloc" class="chart"></p>
    </div>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Difficulty  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="The difficulty measure is related to the difficulty of the program to write or understand." data-original-title="Difficulty" data-container="body"></i></a></h2>
      <p class="stat">69.56</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Estimated Errors  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Halstead's delivered bugs is an estimate for the number of errors in the implementation." data-original-title="Delivered Bugs" data-container="body"></i></a></h2>
      <p class="stat">2.55</p>
    </div>
  </div>
</div>

<div class="container charts">
  <div class="row">
    <h2 class="header">Function weight</h2>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h3 class="chart-header">By Complexity <a href="http://en.wikipedia.org/wiki/Cyclomatic_complexity"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="This metric counts the number of distinct paths through a block of code. Lower values are better." data-original-title="Cyclomatic Complexity" data-container="body"></i></a></h3>
      <div id="fn-by-complexity" class="stat"></div>
    </div>
    <div class="col-md-6">
      <h3 class="chart-header">By SLOC  <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h3>
      <div id="fn-by-sloc" class="stat"></div>
    </div>
  </div>
</div>

<div class="container">
  <div class="row">
    <textarea id="file-source" class="col-md-12">/// &lt;reference path=&#039;../../../ts-definitions/node/node.d.ts&#039; /&gt;
/**
* @class core.search.IndexManager
* @implements core.search.IndexManagerInterface
*/
var IndexManager = (function () {
    function IndexManager(config, folderWatcherManager, pathValidator, searchManager) {
        this._config = null;
        this._folderWatcherManager = null;
        this._isOpen = false;
        this._isIndexing = false;
        this._indexRunnerDelayInMilliSeconds = 10000;
        this._indexRunnerTimeout = -1;
        this._indexRunnersInParallelAmount = 3;
        this._indexRunnersInParallelRunning = 0;
        this._pathValidator = null;
        this._pendingPathsToIndex = {};
        this._currentPendingPathsToIndex = {};
        this._searchManager = null;
        // todo add defaults
        this._config = config;
        this._folderWatcherManager = folderWatcherManager;
        this._pathValidator = pathValidator;
        this._searchManager = searchManager;

        this._indexRunnerDelayInMilliSeconds = this._config.get(&#039;search.indexManager.indexRunnerDelayInMilliSeconds&#039;);
        this._indexRunnersInParallelAmount = this._config.get(&#039;search.indexManager.indexRunnersInParallel&#039;);

        // todo add merged options
        this.open();
    }
    IndexManager.prototype.addToIndex = function (pathToAdd, stats, callback) {
        if (!this._pendingPathsToIndex[pathToAdd]) {
            this._pendingPathsToIndex[pathToAdd] = this._createPendingListObject(pathToAdd, stats, callback);
        }
    };

    IndexManager.prototype.close = function (callback) {
        var _this = this;
        debugger;
        var internalCallback = callback || function (err) {
        };

        if (!this._isOpen) {
            this.pause();
            return process.nextTick(internalCallback.bind(null, null));
        }

        var returned = false;
        var folderWatcherManagerIsClosed = false;
        var searchManagerIsClosed = false;
        var testClose = function (err) {
            if (err) {
                internalCallback(err);
                returned = true;
            } else if (!returned &amp;&amp; folderWatcherManagerIsClosed &amp;&amp; searchManagerIsClosed) {
                _this.pause();
                _this._isOpen = false;
                internalCallback(null);
            }
        };

        this._stopIndexRunner();

        // close folderWatcherManager
        this._folderWatcherManager.close(function (err) {
            folderWatcherManagerIsClosed = true;

            testClose(err);
        });

        // close searchManager
        this._searchManager.close(function (err) {
            searchManagerIsClosed = true;

            testClose(err);
        });
    };

    IndexManager.prototype.forceIndex = function (callback) {
        var internalCallback = callback || function (err) {
        };

        this._processPendingPathsToIndex();
    };

    IndexManager.prototype.isOpen = function (callback) {
        return process.nextTick(callback.bind(null, null, this._isOpen));
    };

    IndexManager.prototype.isPaused = function (callback) {
        return process.nextTick(callback.bind(null, !this._isIndexing));
    };

    IndexManager.prototype.open = function (callback) {
        var _this = this;
        var internalCallback = callback || function (err) {
        };

        if (this._isOpen) {
            this.resume();
            return process.nextTick(internalCallback.bind(null, null));
        }

        var returned = false;
        var folderWatcherManagerIsOpen = false;
        var searchManagerIsOpen = false;
        var testOpen = function (err) {
            if (err) {
                internalCallback(err);
                returned = true;
            } else if (!returned &amp;&amp; folderWatcherManagerIsOpen &amp;&amp; searchManagerIsOpen) {
                _this._isOpen = true;
                _this.resume();

                internalCallback(null);
            }
        };

        this._folderWatcherManager.open(function (err) {
            folderWatcherManagerIsOpen = true;

            testOpen(err);
        });

        this._bindToFolderWatcherManagerEvents();

        this._searchManager.open(function (err) {
            searchManagerIsOpen = true;

            testOpen(err);
        });
    };

    IndexManager.prototype.pause = function (callback) {
        var internalCallback = callback || function (err) {
        };

        if (this._isIndexing) {
            //console.log(&#039;stopping the index runner&#039;);
            this._stopIndexRunner();
            this._isIndexing = false;
        }

        return process.nextTick(internalCallback.bind(null, null));
    };

    IndexManager.prototype.resume = function (callback) {
        var internalCallback = callback || function (err) {
        };

        if (!this._isIndexing) {
            //console.log(&#039;starting the index runner&#039;);
            this._isIndexing = true;
            this._startIndexRunner();
        }

        return process.nextTick(internalCallback.bind(null, null));
    };

    IndexManager.prototype._bindToFolderWatcherManagerEvents = function () {
        this._folderWatcherManager.on(&#039;add&#039;, function (changedPath, stats) {
            //this._triggerEvent(&#039;add&#039;, changedPath, stats);
        });
        this._folderWatcherManager.on(&#039;change&#039;, function (changedPath, stats) {
            //this._triggerEvent(&#039;change&#039;, changedPath, stats);
        });
        this._folderWatcherManager.on(&#039;unlink&#039;, function (changedPath, stats) {
            //this._triggerEvent(&#039;unlink&#039;, changedPath, stats);
        });
    };

    IndexManager.prototype._indexRunner = function () {
        ////console.log(&#039;pending&#039;);
        ////console.log(this._pendingPathsToIndex);
        // copy items from the pending paths list into the current batch
        if (Object.keys(this._pendingPathsToIndex).length) {
            for (var pathToIndex in this._pendingPathsToIndex) {
                this._currentPendingPathsToIndex[pathToIndex] = this._pendingPathsToIndex[pathToIndex];

                delete this._pendingPathsToIndex[pathToIndex];
                //console.log(this._currentPendingPathsToIndex[pathToIndex]);
            }

            this._processPendingPathsToIndex();
        }

        ////console.log(&#039;current&#039;);
        ////console.log(this._currentPendingPathsToIndex);
        this._startIndexRunner();
    };

    IndexManager.prototype._processPendingPathsToIndex = function () {
        //console.log(&#039;process pending path to index&#039;);
        // run x index processes in parallel
        var processesStarted = 0;
        var created = true;

        while (created &amp;&amp; processesStarted &lt; this._indexRunnersInParallelAmount) {
            created = this._createPendingPathProcessor();
        }
    };

    // todo add return type
    IndexManager.prototype._createPendingListObject = function (pathToIndex, stats, callback) {
        return {
            isIndexing: false,
            stats: stats,
            callback: callback || function () {
            }
        };
    };

    /**
    * @returns {boolean} processor created
    */
    IndexManager.prototype._createPendingPathProcessor = function () {
        var _this = this;
        var pathToIndex = null;
        var pathData = null;
        var created = false;

        if (Object.keys(this._currentPendingPathsToIndex).length &amp;&amp; this._isIndexing) {
            for (var pendingPath in this._currentPendingPathsToIndex) {
                if (!this._currentPendingPathsToIndex[pendingPath].isIndexing) {
                    pathToIndex = pendingPath;
                    pathData = this._currentPendingPathsToIndex[pendingPath];

                    break;
                }
            }

            if (pathToIndex &amp;&amp; pathData) {
                //console.log(&#039;created parallel index runner for&#039;, pathToIndex);
                this._processPendingPathToIndex(pathToIndex, pathData.stats, function (err) {
                    _this._indexRunnersInParallelRunning--;

                    // call callback and clean up current list
                    _this._removeCurrentPendingPathToIndex(pathToIndex, err);

                    if (_this._indexRunnersInParallelRunning &lt; _this._indexRunnersInParallelAmount) {
                        // create a new processor
                        _this._createPendingPathProcessor();
                    }
                });

                this._indexRunnersInParallelRunning++;
                created = true;
            }
        }

        return created;
    };

    /**
    * Processes an item from teh {@link core.search.IndexManager~_currentPendingPathToIndex} list.
    * It checkes weather the item exists in the searchManager by using {@link core.search.IndexManager~_getItemFromSearchManager}
    * and validates the returned state via {@link core.search.IndexManager~_validateItem}. If the item does not exists yet
    * or needs reindexing it is passed to the {@link core.search.IndexManager~_addItem} method.
    *
    * @method core.search.IndexManager~_processPendingPathToIndex
    *
    * @param {string} pathToIndex
    * @param {fs.Stats} stats
    * @param {Function} callback
    */
    IndexManager.prototype._processPendingPathToIndex = function (pathToIndex, stats, callback) {
        var _this = this;
        this._currentPendingPathsToIndex[pathToIndex].isIndexing = true;

        this._getItemStatsFromSearchManager(pathToIndex, function (searchManagerHash, searchManagerStats) {
            // item exists
            if (searchManagerStats) {
                ////console.log(&#039;validating item&#039;);
                _this._validateItem(pathToIndex, searchManagerHash, searchManagerStats, function (err, isValid, fileHash, fileStats) {
                    //console.log(&#039;item is valid:&#039;, isValid);
                    if (isValid) {
                        //console.log(&#039;item is already fully indexed&#039;);
                        // todo check against the amount of plugins which indexed this file. Maybe some plugins are new
                        callback(new Error(&#039;IndexManager~_processPendingPathToIndex: The item at path &quot;&#039; + pathToIndex + &#039;&quot; is already indexed.&#039;));
                    } else {
                        _this._addItem(pathToIndex, stats, callback);
                    }
                });
                /**/
            } else {
                // adding new item
                _this._addItem(pathToIndex, stats, callback);
            }
        });
    };

    /**
    * Adds an path to the Database by passing it to the {@link core.search.SearchManagerInterface#addItem} method
    *
    * @method core.search.IndexManager~_addItem
    *
    * @param {string} pathToAdd
    * @param {fs.Stats} stats
    * @param {Function} callback
    */
    IndexManager.prototype._addItem = function (pathToAdd, stats, callback) {
        this._searchManager.addItem(pathToAdd, stats, function (err) {
            if (err) {
                // todo reset isIndexing flag
                return callback(err);
            }

            return callback(null);
        });
    };

    /**
    * Returns the stats and the file hash returned from the {@link core.search.IndexManagerInteface#getItem} for the given path
    *
    * @method core.search.IndexManager~_getItemStatsFromSearchManager
    *
    * @param {string} pathToIndex
    * @param {Function} callback
    */
    IndexManager.prototype._getItemStatsFromSearchManager = function (pathToIndex, callback) {
        this._searchManager.getItem(pathToIndex, function (hash, stats) {
            callback(hash, stats);
        });
    };

    /**
    * Two step validation against the model in the database.
    * The first step is a fs.Stats validation using the {@link core.fs.PathValidator#validateStats}
    * If the first step fails a second check using {@link core.fs.PathValidator#validateHash} will be performed.
    *
    * @param {string} itemPath
    * @param {string} searchManagerItemHash
    * @param {fs.Stats} searchManagerItemStats
    * @param {Function} callback
    */
    IndexManager.prototype._validateItem = function (itemPath, searchManagerItemHash, searchManagerItemStats, callback) {
        var _this = this;
        // 1. step: validating stats
        this._pathValidator.validateStats(itemPath, searchManagerItemStats, function (err, statsAreValid, fileStats) {
            if (err) {
                return callback(err, false, null, null);
            } else if (statsAreValid) {
                return callback(null, statsAreValid, null, null);
            } else {
                // 2. step: validating file hash
                _this._pathValidator.validateHash(itemPath, searchManagerItemHash, function (err, hashIsValid, fileHash) {
                    if (err) {
                        return callback(err, false, null, null);
                    }
                    if (hashIsValid) {
                        return callback(null, hashIsValid, null, null);
                    } else {
                        return callback(null, false, fileHash, fileStats);
                    }
                });
            }
        });
    };

    /**
    * Calls the callback method stored for the path and removes it from the processing list.
    *
    * @param {string} pathToIndex
    * @param {Error} err
    */
    IndexManager.prototype._removeCurrentPendingPathToIndex = function (pathToIndex, err) {
        //console.log(&#039;removing from current list and calling callback for&#039;, pathToIndex);
        this._currentPendingPathsToIndex[pathToIndex].callback(err);

        delete this._currentPendingPathsToIndex[pathToIndex];
    };

    /**
    * Starts the index runner which starts the index process after the specified
    * {@link core.search.IndexManager~__indexRunnerDelayInMilliSeconds} delay.
    *
    * @method core.search.IndexManager~_startIndexRunner
    */
    IndexManager.prototype._startIndexRunner = function () {
        var _this = this;
        if (this._isIndexing) {
            this._indexRunnerTimeout = setTimeout(function () {
                ////console.log(&#039;index runner interval&#039;);
                ////console.log(this._pendingPathsToIndex);
                _this._indexRunner();
            }, this._indexRunnerDelayInMilliSeconds);
        }
    };

    /**
    * Stops the previous started index runner.
    *
    * @method core.search.IndexManager~_stopIndexRunner
    */
    IndexManager.prototype._stopIndexRunner = function () {
        if (this._indexRunnerTimeout) {
            clearTimeout(this._indexRunnerTimeout);
        }
    };
    return IndexManager;
})();

module.exports = IndexManager;
//# sourceMappingURL=IndexManager.js.map</textarea>
  </div>
</div>

<footer class="footer">
  <div class="container">
    <p>.</p>
  </div>
</footer>

<script type="text/html" id="complexity-popover-template">
  <div class="complexity-notice">
    Complexity : {{ complexity.cyclomatic }} <br>
    Length : {{ complexity.halstead.length }} <br>
    Difficulty : {{ complexity.halstead.difficulty.toFixed(2) }} <br>
    Est # bugs : {{ complexity.halstead.bugs.toFixed(2) }}<br>
  </div>
</script>

<script type="text/javascript" src="../../assets/scripts/bundles/core-bundle.js"></script>
<script type="text/javascript" src="../../assets/scripts/bundles/codemirror.js"></script>
<script type="text/javascript" src="../../assets/scripts/codemirror.markpopovertext.js"></script>
<script type="text/javascript" src="report.js"></script>
<script type="text/javascript" src="report.history.js"></script>
<script type="text/javascript" src="../../assets/scripts/plato-file.js"></script>
</body>
</html>
